From f378e164c249419daa5f353b058ae71a1e5e3ba3 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Micka=C3=ABl=20Tansorier?= <mickael.tansorier@openwide.fr>
Date: Wed, 20 Apr 2016 17:30:39 +0200
Subject: [PATCH] virtio i2c: Create I2C virtio driver

in progress

virtio i2c: Add id for i2c to virtio id definition

65535 is required for experimental drivers.

virtio i2c: Add config VIRTIO_I2C to kernel

virtio i2c: add transport message structure

virtio i2c: changement i2c register between 3.10 and 4.5

virtio i2c: add completion to xfer function

virtio i2c: Add print and clean comment

virtio i2c: correct pointing for sg, and return of function

virtio i2c: Change few print and waraning

virtio i2c: add macro for print log

virtio i2c: suppr addr test, suppr unnecessary ligne

virtio i2c: Add correct node to adapter

virtio i2c: Add description and remove unsued include

virtio i2c: change init of virtio i2c

virtio i2c: correct warning on error return

virtio i2c: change free mem order

virtio i2c: move function

virtio i2c: clean file
---
 drivers/i2c/Kconfig             |   6 +
 drivers/i2c/Makefile            |   1 +
 drivers/i2c/virtio_i2c.c        | 288 ++++++++++++++++++++++++++++++++++++++++
 include/uapi/linux/virtio_i2c.h |  10 ++
 include/uapi/linux/virtio_ids.h |   1 +
 5 files changed, 306 insertions(+)
 create mode 100644 drivers/i2c/virtio_i2c.c
 create mode 100644 include/uapi/linux/virtio_i2c.h

diff --git a/drivers/i2c/Kconfig b/drivers/i2c/Kconfig
index 78fbee4..dfd0694 100644
--- a/drivers/i2c/Kconfig
+++ b/drivers/i2c/Kconfig
@@ -144,6 +144,12 @@ config I2C_DEBUG_BUS
 	  a problem with I2C support and want to see more of what is going
 	  on.
 
+config VIRTIO_I2C
+	tristate "Virtio i2c driver"
+	depends on VIRTIO
+	---help---
+	  This is the virtual i2c driver for virtio.
+
 endif # I2C
 
 endmenu
diff --git a/drivers/i2c/Makefile b/drivers/i2c/Makefile
index 45095b3..af7d7cb 100644
--- a/drivers/i2c/Makefile
+++ b/drivers/i2c/Makefile
@@ -10,6 +10,7 @@ obj-$(CONFIG_I2C_MUX)		+= i2c-mux.o
 obj-y				+= algos/ busses/ muxes/
 obj-$(CONFIG_I2C_STUB)		+= i2c-stub.o
 obj-$(CONFIG_I2C_SLAVE_EEPROM)	+= i2c-slave-eeprom.o
+obj-$(CONFIG_VIRTIO_I2C)	+= virtio_i2c.o
 
 ccflags-$(CONFIG_I2C_DEBUG_CORE) := -DDEBUG
 CFLAGS_i2c-core.o := -Wno-deprecated-declarations
diff --git a/drivers/i2c/virtio_i2c.c b/drivers/i2c/virtio_i2c.c
new file mode 100644
index 0000000..8b90679
--- /dev/null
+++ b/drivers/i2c/virtio_i2c.c
@@ -0,0 +1,288 @@
+/**
+ * Copyright (C) 2015 Institut de Recherche Technologique SystemX and OpenWide.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * @file virtio_i2c.c
+ * @author MickaÃ«l TANSORIER (mickael.tansorier@openwide.fr)
+ * @brief i2c virtio.
+ * @details This source file implements the virtio for i2c for xVisor.
+ *
+ */
+
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/scatterlist.h>
+#include <linux/spinlock.h>
+#include <linux/virtio.h>
+#include <linux/virtio_i2c.h>
+#include <linux/module.h>
+#include <linux/completion.h>
+
+struct virtio_i2c
+{
+	struct virtio_device *vdev;
+	struct virtqueue *vq;
+	struct transport_msgs *trans_msgs;
+
+	spinlock_t out_lock;
+
+	struct i2c_adapter adapter;
+
+	/* to wait recept data before living xfer */
+	struct completion recep_done;
+
+	/* Scatterlist */
+	struct scatterlist sg;
+};
+
+struct transport_msgs
+{
+	__u16 addr;
+	__u16 flags;
+	__u16 len;
+	__u8 *buf;
+	int result;
+};
+
+static int i2c_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs, int num)
+{
+	struct virtio_i2c *vi2c;
+	int ret=0;
+	struct scatterlist *sgs[5], addr, flags, len, buf, result;
+	struct transport_msgs *trans_msgs;
+	unsigned int num_out = 0, num_in = 0;	
+
+	/* Get adapter */
+	vi2c = i2c_get_adapdata(adapter);
+
+	/* generate structure to send */
+	trans_msgs = vi2c->trans_msgs;
+	trans_msgs->addr = msgs->addr;
+	trans_msgs->flags = msgs->flags;
+	trans_msgs->len = msgs->len;
+	trans_msgs->buf = msgs->buf;
+	trans_msgs->result = 0;
+
+	/* Set scatter list with message structure */
+	// adresse
+	sg_init_one(&addr, &trans_msgs->addr, sizeof(trans_msgs->addr));
+	sgs[num_out++] = &addr;
+	// flags
+	sg_init_one(&flags, &trans_msgs->flags, sizeof(trans_msgs->flags));
+	sgs[num_out++] = &flags;
+	// length and bufffer
+	sg_init_one(&len, &trans_msgs->len, sizeof(trans_msgs->len));
+	sg_init_one(&buf, trans_msgs->buf, sizeof(trans_msgs->buf));
+	if (msgs->flags & I2C_M_RD)
+	{
+		sgs[num_out + num_in++] = &len;
+		sgs[num_out + num_in++] = &buf;
+	}
+	else
+	{
+		sgs[num_out++] = &len;
+		sgs[num_out++] = &buf;
+	}
+	// retrun
+	sg_init_one(&result, &trans_msgs->result, sizeof(trans_msgs->result));
+	sgs[num_out + num_in++] = &result;
+	
+	/* Try tu send message */
+	ret = virtqueue_add_sgs(vi2c->vq, sgs, num_out, num_in, trans_msgs,
+								 GFP_ATOMIC);
+	if (ret < 0)
+		goto fail;
+
+	/* Sen msgs */
+	virtqueue_kick(vi2c->vq);
+
+	/* wait event */
+	wait_for_completion(&vi2c->recep_done);
+
+	/* recept result */
+	ret = trans_msgs->result;
+	
+	return (ret < 0) ? ret : num;
+
+fail:
+	return ret;
+}
+
+static u32 i2c_func(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
+}
+
+static struct i2c_algorithm i2c_algo = {
+	.master_xfer	= i2c_xfer,
+	.functionality	= i2c_func,
+};
+
+static void virti2c_done(struct virtqueue *vq)
+{
+	unsigned int len;
+	struct virtio_i2c *vi2c = vq->vdev->priv;
+
+	/* lock callback */
+	virtqueue_disable_cb(vq);
+
+	virtqueue_get_buf(vq, &len);
+
+	virtqueue_enable_cb(vq);
+
+	/* free completion of xfer */
+	complete(&vi2c->recep_done);
+}
+
+static int init_vqs(struct virtio_i2c *vi2c)
+{
+	int err=0;
+
+	vi2c->vq = virtio_find_single_vq(vi2c->vdev, virti2c_done, "requests");
+	if (IS_ERR(vi2c->vq))
+		err = PTR_ERR(vi2c->vq);
+
+	return err;
+}
+
+static int virti2c_probe(struct virtio_device *vdev)
+{
+	int err;
+	struct virtio_i2c *vi2c;
+
+	/* init virtio i2c structure */
+	vi2c = devm_kzalloc(&vdev->dev, sizeof(struct virtio_i2c), GFP_KERNEL);
+	if (!vi2c) {
+		err = -ENOMEM;
+		goto out;
+	}
+	/* Attach this vi2c to this virtio_device, and vice-versa. */
+	vdev->priv = vi2c;
+	vi2c->vdev = vdev;
+
+	/* init scatter list */
+	sg_init_table(&vi2c->sg, 1);
+	spin_lock_init(&vi2c->out_lock);
+
+	/* init completion */
+	init_completion(&vi2c->recep_done);
+
+	/* init transport message structure */
+	vi2c->trans_msgs = devm_kzalloc(&vdev->dev, 
+				sizeof(struct transport_msgs), GFP_KERNEL);
+	if (!vi2c->trans_msgs) {
+		err = -ENOMEM;
+		goto out_free_vi2c;
+	}
+
+	/* init virtio queues */
+	err = init_vqs(vi2c);
+	if (err < 0) {
+		dev_err(&vdev->dev, "Error %d initializing vqs\n", err);
+		goto out_free_trans_msgs;
+	}
+
+	/* Setup i2c_imx driver structure */
+	strlcpy(vi2c->adapter.name, KBUILD_MODNAME, sizeof(vi2c->adapter.name));
+	vi2c->adapter.owner		= THIS_MODULE;
+	vi2c->adapter.algo		= &i2c_algo;
+	vi2c->adapter.dev.parent	= &vdev->dev;
+	vi2c->adapter.dev.of_node	= vdev->dev.parent->of_node;
+
+	/* Attach virtio_i2c to adapter */
+	i2c_set_adapdata(&vi2c->adapter, vi2c);
+
+	/* Add I2C adapter */
+	err = i2c_add_adapter(&vi2c->adapter);
+	if (err < 0) {
+		dev_err(&vdev->dev, "registration failed\n");
+		goto out_free_trans_msgs;
+	}
+
+	return 0;
+
+out_free_trans_msgs:
+	kfree(vi2c->trans_msgs);
+out_free_vi2c:
+	kfree(vi2c);
+out:
+	return err;
+}
+
+static void virti2c_remove(struct virtio_device *vdev)
+{
+	struct virtio_i2c *vi2c = vdev->priv;
+
+	/* remove adapter */
+	i2c_del_adapter(&vi2c->adapter);
+	/* Stop all the virtqueues. */
+	vdev->config->del_vqs(vdev);
+	vdev->config->reset(vdev);
+	/* free */
+	kfree(vi2c->trans_msgs);
+	kfree(vi2c);
+}
+
+/* Add here futur features */
+//static unsigned int features[] = {
+//	VIRTIO_XXX, VIRTIO_YYY,
+//	...
+//};
+
+static struct virtio_device_id id_table[] = {
+	{ VIRTIO_ID_I2C, VIRTIO_DEV_ANY_ID },
+	{ 0 },
+};
+
+//static void virti2c_config_changed(struct virtio_device *vdev)
+//{
+//}
+
+#ifdef CONFIG_PM
+static int virti2c_freeze(struct virtio_device *vdev)
+{
+	struct virtio_i2c *vi2c = vdev->priv;
+
+	virti2c_remove(vdev);
+	return 0;
+}
+
+static int virti2c_restore(struct virtio_device *vdev)
+{
+	return virti2c_probe(vdev);
+}
+#endif
+
+static struct virtio_driver virtio_i2c_driver = {
+//	.feature_table = features,
+//	.feature_table_size = ARRAY_SIZE(features),
+	.driver.name =	KBUILD_MODNAME,
+	.driver.owner =	THIS_MODULE,
+	.id_table =	id_table,
+	.probe =	virti2c_probe,
+	.remove =	virti2c_remove,
+//	.config_changed		= virti2c_config_changed,
+#ifdef CONFIG_PM
+	.freeze =	virti2c_freeze,
+	.restore =	virti2c_restore,
+#endif
+};
+
+module_virtio_driver(virtio_i2c_driver);
+MODULE_DEVICE_TABLE(virtio, id_table);
+MODULE_DESCRIPTION("Virtio i2c driver");
+MODULE_LICENSE("GPL");
diff --git a/include/uapi/linux/virtio_i2c.h b/include/uapi/linux/virtio_i2c.h
new file mode 100644
index 0000000..6af4b1e
--- /dev/null
+++ b/include/uapi/linux/virtio_i2c.h
@@ -0,0 +1,10 @@
+#ifndef _LINUX_VIRTIO_I2C_H
+#define _LINUX_VIRTIO_I2C_H
+
+/* This header is BSD licensed so anyone can use the definitions to implement
+ * compatible drivers/servers. */
+
+#include <linux/virtio_ids.h>
+#include <linux/virtio_config.h>
+
+#endif /* _LINUX_VIRTIO_I2C_H */
diff --git a/include/uapi/linux/virtio_ids.h b/include/uapi/linux/virtio_ids.h
index 77925f5..8236923 100644
--- a/include/uapi/linux/virtio_ids.h
+++ b/include/uapi/linux/virtio_ids.h
@@ -41,5 +41,6 @@
 #define VIRTIO_ID_CAIF	       12 /* Virtio caif */
 #define VIRTIO_ID_GPU          16 /* virtio GPU */
 #define VIRTIO_ID_INPUT        18 /* virtio input */
+#define VIRTIO_ID_I2C        65535 /* virtio i2c */
 
 #endif /* _LINUX_VIRTIO_IDS_H */
-- 
1.9.1

