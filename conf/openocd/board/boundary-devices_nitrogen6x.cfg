#
# This file is part of Xvisor Build Environment.
# Copyright (C) 2015 Institut de Recherche Technologique SystemX
# Copyright (C) 2015 OpenWide
# All rights reserved.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this Xvisor Build Environment. If not, see
# <http://www.gnu.org/licenses/>.
#
# @file conf/openocd/board/boundary-devices_nitrogen6x.cfg
#

# Boundary Devices Nitrogen 6x board
#  http://boundarydevices.com/products/nitrogen6x-board-imx6-arm-cortex-a9-sbc
# Author: Jimmy Durand Wesolowski <jimmy.durand.wesolowski@openwide.fr>
# Date: May, 20 th 2014
# Inspired by the openocd.cfg from
#   https://community.freescale.com/thread/308778

source [find target/imx6.cfg]

# The JTAG must be also be reset.
jtag_ntrst_delay 100

# This delay affects how soon after SRST we try to halt, so make it as
# small as possible. However, if it is too small we will fail the JTAG
# scan (consider the reset delay required by the TPS3808).
# Delay determined by experimentation.
#
# The timing should be short enough to avoid some UBoot initialisation,
# but long enough to reset the board.
adapter_nsrst_delay 1000
reset_config trst_and_srst srst_pulls_trst

$_TARGETNAME configure -work-area-phys 0x00900000 -work-area-size 0x4000 \
    -work-area-backup 0

$_TARGETNAME configure -event reset-assert {
    puts "### Reset assert"
    halt
}

$_TARGETNAME configure -event reset-start {
    puts "### Reset start"
    adapter_khz 1000
}

$_TARGETNAME configure -event gdb-attach {
    puts "### GDB attach"
}

$_TARGETNAME configure -event reset-init {
    puts "### Reset init"
    dap apsel 1

    adapter_khz 1000

    arm core_state arm
    puts "Disable interrupts"
    disable_interrupts
    puts "Disable caches"
    cache_disable
    puts "Reset DDR"
    ddr_reset
    ddr_init
    adapter_khz 100
    ddr_1066mhz_4x128mx16
    clocks_init

    dap apsel 0
    adapter_khz 20000
}

# Xvisor load is generated
proc xvisor_launch {} {
     xvisor_load
     resume
}

proc wdog_reset {} {
    mwh phys 0x20bc000 4
}

proc disable_interrupts {} {
    # Keep the mode to 0x13, the supervisor mode
    reg cpsr 0x13
}

proc cache_disable {} {
    set mask [expr (1 << 12) | (1 << 2) | (1 << 1) | (1 << 0)]

    poll
    puts "Disable Caches"
    # Syntax: arm mrc cpnum op1 CRn CRm op2
    set scr [arm mrc 15 0 1 0 0]
    # Syntax: arm mcr cpnum op1 CRn CRm op2 value
    arm mcr 15 0 1 0 0 [expr $scr & ~($mask)]

    poll
    puts "Invalidate Caches"
    # I+BTB cache invalidate
    arm mcr 15 0 10 7 0 0

    # Flush TLB
    poll
    puts "Invalidate entire unified TLB"
    arm mcr 15 0 8 7 0 0
    puts "Invalidate entire data TLB"
    arm mcr 15 0 8 6 0 0
    puts "Invalidate entire instruction TLB"
    arm mcr 15 0 8 5 0 0

    puts "Invalidate all instruction caches to PoU."
    arm mcr 15 0 7 5 0 0
    puts "Invalidate branch predictor array"
    arm mcr 15 0 7 5 6 0

    puts "Full system DSB - make sure that the invalidation is complete"
    arm mcr 15 0 7 10 4 0
    puts "ISB - make sure the instruction stream sees it"
    arm mcr 15 0 7 5 4 0

    # write a nop
    mww 0x00904000 0xe1a00000
    # Step on it
    step 0x00904000
    # MMU should be off
    poll

    puts "Disable L2X0 cache"
    set L2X0_CTRL 0x00a02100
    mww $L2X0_CTRL 0
    phys_mem2array ctrl 32 $L2X0_CTRL 1
    while {[expr {$ctrl(0) & 1}]} {phys_mem2array ctrl 32 $L2X0_CTRL 1}

}

proc ddr_reset {} {
    source [find target/imx6-regs.cfg]

    set mapsr_reset 0x00001076
    set mdmisc_reset 0x40081740

    # mdw phys $MX6_MMDC_P0_MAPSR
    # The MMDC should enter self-refresh mode. This can be achieved by either LPMD or
    # DFVS request.
    set mapsr_refresh [expr $mapsr_reset | (1 << 20 | 1 << 21)]
    mww phys $MX6_MMDC_P0_MAPSR $mapsr_refresh

    # Wait for LPMD or DVFS acknowledge
    # Waiting 1ms is largely enough
    sleep 1

    # Assert software reset, by setting MDMISC[RST]
    set $mdmisc_reset [expr $mdmisc_reset | 1 << 1]
    mww phys $MX6_MMDC_P0_MDMISC $mdmisc_reset

    # Get out of the LPMD/DVFS mode
    mww phys $MX6_MMDC_P0_MAPSR $mapsr_reset
}

proc ddr_init {} {
    puts "### Initializing DDR"
    source [find target/imx6-regs.cfg]

    # ddr-setup.cfg
    mww phys $MX6_IOM_DRAM_SDQS0 0x00000030
    mww phys $MX6_IOM_DRAM_SDQS1 0x00000030
    mww phys $MX6_IOM_DRAM_SDQS2 0x00000030
    mww phys $MX6_IOM_DRAM_SDQS3 0x00000030
    mww phys $MX6_IOM_DRAM_SDQS4 0x00000030
    mww phys $MX6_IOM_DRAM_SDQS5 0x00000030
    mww phys $MX6_IOM_DRAM_SDQS6 0x00000030
    mww phys $MX6_IOM_DRAM_SDQS7 0x00000030

    mww phys $MX6_IOM_GRP_B0DS 0x00000030
    mww phys $MX6_IOM_GRP_B1DS 0x00000030
    mww phys $MX6_IOM_GRP_B2DS 0x00000030
    mww phys $MX6_IOM_GRP_B3DS 0x00000030
    mww phys $MX6_IOM_GRP_B4DS 0x00000030
    mww phys $MX6_IOM_GRP_B5DS 0x00000030
    mww phys $MX6_IOM_GRP_B6DS 0x00000030
    mww phys $MX6_IOM_GRP_B7DS 0x00000030
    mww phys $MX6_IOM_GRP_ADDDS 0x00000030
    # 40 Ohm drive strength for cs0/1,sdba2,cke0/1,sdwe
    mww phys $MX6_IOM_GRP_CTLDS 0x00000030

    mww phys $MX6_IOM_DRAM_DQM0 0x00020030
    mww phys $MX6_IOM_DRAM_DQM1 0x00020030
    mww phys $MX6_IOM_DRAM_DQM2 0x00020030
    mww phys $MX6_IOM_DRAM_DQM3 0x00020030
    mww phys $MX6_IOM_DRAM_DQM4 0x00020030
    mww phys $MX6_IOM_DRAM_DQM5 0x00020030
    mww phys $MX6_IOM_DRAM_DQM6 0x00020030
    mww phys $MX6_IOM_DRAM_DQM7 0x00020030

    mww phys $MX6_IOM_DRAM_CAS 0x00020030
    mww phys $MX6_IOM_DRAM_RAS 0x00020030
    mww phys $MX6_IOM_DRAM_SDCLK_0 0x00020030
    mww phys $MX6_IOM_DRAM_SDCLK_1 0x00020030

    mww phys $MX6_IOM_DRAM_RESET 0x00020030
    mww phys $MX6_IOM_DRAM_SDCKE0 0x00003000
    mww phys $MX6_IOM_DRAM_SDCKE1 0x00003000

    mww phys $MX6_IOM_DRAM_SDODT0 0x00003030
    mww phys $MX6_IOM_DRAM_SDODT1 0x00003030

    # (differential input)
    mww phys $MX6_IOM_DDRMODE_CTL 0x00020000
    # (differential input)
    mww phys $MX6_IOM_GRP_DDRMODE 0x00020000
    # disable ddr pullups
    mww phys $MX6_IOM_GRP_DDRPKE 0x00000000
    mww phys $MX6_IOM_DRAM_SDBA2 0x00000000
    # 40 Ohm drive strength for cs0/1,sdba2,cke0/1,sdwe
    mww phys $MX6_IOM_GRP_DDR_TYPE 0x000C0000

    # Read data DQ Byte0-3 delay
    mww phys $MX6_MMDC_P0_MPRDDQBY0DL 0x33333333
    mww phys $MX6_MMDC_P0_MPRDDQBY1DL 0x33333333
    mww phys $MX6_MMDC_P0_MPRDDQBY2DL 0x33333333
    mww phys $MX6_MMDC_P0_MPRDDQBY3DL 0x33333333
    mww phys $MX6_MMDC_P1_MPRDDQBY0DL 0x33333333
    mww phys $MX6_MMDC_P1_MPRDDQBY1DL 0x33333333
    mww phys $MX6_MMDC_P1_MPRDDQBY2DL 0x33333333
    mww phys $MX6_MMDC_P1_MPRDDQBY3DL 0x33333333

    # MDMISC	mirroring	interleaved (row/bank/col)
    mww phys $MX6_MMDC_P0_MDMISC 0x00081740

    # MDSCR	con_req
    mww phys $MX6_MMDC_P0_MDSCR 0x00008000
    sleep 1000
    runtest 1000
}

proc ddr_1066mhz_4x128mx16 {} {
    puts "### Setting DDR mapping"
    source [find target/imx6-regs.cfg]

    # 1066mhz_4x128mx16.cfg
    mww phys $MX6_MMDC_P0_MDPDC 0x00020036
    mww phys $MX6_MMDC_P0_MDSCR 0x00008000
    mww phys $MX6_MMDC_P0_MDCFG0 0x555A7974
    mww phys $MX6_MMDC_P0_MDCFG1 0xDB538F64
    mww phys $MX6_MMDC_P0_MDCFG2 0x01FF00DB
    mww phys $MX6_MMDC_P0_MDRWD 0x000026D2
    mww phys $MX6_MMDC_P0_MDOR 0x005A1023
    mww phys $MX6_MMDC_P0_MDOTC 0x09444040
    mww phys $MX6_MMDC_P0_MDPDC 0x00025576
    mww phys $MX6_MMDC_P0_MDASP 0x00000027
    mww phys $MX6_MMDC_P0_MDCTL 0x831A0000
    mww phys $MX6_MMDC_P0_MDSCR 0x04088032
    mww phys $MX6_MMDC_P0_MDSCR 0x00008033
    mww phys $MX6_MMDC_P0_MDSCR 0x00428031
    mww phys $MX6_MMDC_P0_MDSCR 0x19308030
    mww phys $MX6_MMDC_P0_MDSCR 0x04008040
    mww phys $MX6_MMDC_P0_MPZQHWCTRL 0xA1390003
    mww phys $MX6_MMDC_P1_MPZQHWCTRL 0xA1390003
    mww phys $MX6_MMDC_P0_MDREF 0x00005800
    mww phys $MX6_MMDC_P0_MPODTCTRL 0x00022227
    mww phys $MX6_MMDC_P1_MPODTCTRL 0x00022227
    mww phys $MX6_MMDC_P0_MPDGCTRL0 0x42720306
    mww phys $MX6_MMDC_P0_MPDGCTRL1 0x026F0266
    mww phys $MX6_MMDC_P1_MPDGCTRL0 0x4273030A
    mww phys $MX6_MMDC_P1_MPDGCTRL1 0x02740240
    mww phys $MX6_MMDC_P0_MPRDDLCTL 0x45393B3E
    mww phys $MX6_MMDC_P1_MPRDDLCTL 0x403A3747
    mww phys $MX6_MMDC_P0_MPWRDLCTL 0x40434541
    mww phys $MX6_MMDC_P1_MPWRDLCTL 0x473E4A3B
    mww phys $MX6_MMDC_P0_MPWLDECTRL0 0x0011000E
    mww phys $MX6_MMDC_P0_MPWLDECTRL1 0x000E001B
    mww phys $MX6_MMDC_P1_MPWLDECTRL0 0x00190015
    mww phys $MX6_MMDC_P1_MPWLDECTRL1 0x00070018
    mww phys $MX6_MMDC_P0_MPMUR0 0x00000800
    mww phys $MX6_MMDC_P1_MPMUR0 0x00000800
    mww phys $MX6_MMDC_P0_MDSCR 0x00000000
    mww phys $MX6_MMDC_P0_MAPSR 0x00011006
}

proc clocks_init {} {
    puts "### Initializing clocks"
    source [find target/imx6-regs.cfg]

    # clocks.cfg
    mww phys $CCM_CCGR0 0x00C03F3F
    mww phys $CCM_CCGR1 0x0030FC03
    mww phys $CCM_CCGR2 0x0FFFC000
    mww phys $CCM_CCGR3 0x3FF00000
    mww phys $CCM_CCGR4 0x00FFF300
    mww phys $CCM_CCGR5 0x0F0000C3
    mww phys $CCM_CCGR6 0x000003FF
}


proc v2p { VA } {
    set mmu_enabled [expr [arm mrc 15 0 1 0 0] & (1 << 0)]
    if {$mmu_enabled == 0} {
	puts "MMU is disabled"
	return;
    }

    set l1ttba [arm mrc 15 0 2 0 0]
    set l1ttba [expr $l1ttba & 0xFFFFC000]
    puts [format "L1 Base: 0x%X" $l1ttba]

    set l1_offset [expr $VA >> 20]

    set l1tte_addr [expr $l1ttba + ($l1_offset << 2) ]
    phys_mem2array l1tte 32 $l1tte_addr 1
    set l1tte $l1tte(0)

    puts [format "L1 TTBA\[%d\]: 0x%X" $l1_offset $l1tte]

    set l1tte_type [expr $l1tte & 0x3]

    if {$l1tte_type == 0x1} {
	puts "L1 TTE L2 table type"

	set l2ttba [expr $l1tte & 0xFFFFFC00]
	puts [format "L2 Base: 0x%X" $l2ttba]
	set l2_offset [expr ($VA & 0x000FF000) >> 12]

	set l2tte_addr [expr ($l1tte & 0xFFFFFC00) + ($l2_offset << 2)]
	phys_mem2array l2tte 32 $l2tte_addr 1
	set l2tte $l2tte(0)
	puts [format "L2 TTBA\[%d\]: 0x%X" $l2_offset $l2tte]

	set pa [expr ($l2tte & 0xFFFFF000) | ($VA & 0xFFF)]
	phys_mem2array val 32 $pa 1
	puts [format "VA (0x%08X), PA (0x%08X): 0x%08X" $VA $pa $val(0)]
    } elseif {$l1tte_type == 0x2} {
	puts "L1 TTE section type"
    } elseif {$l1tte_type == 0x3 } {
	puts "L1 TTE reserved type"
    } else {
	puts "Error on L1 TTE"
    }
}


# .macro	dcache_line_size, reg, tmp
# .endm

# dcache_line_size - get the minimum D-cache line size from the CTR register
# on ARMv7.
proc dcache_line_size {} {
    #	mrc	p15, 0, \tmp, c0, c0, 1		@ read ctr
    # Syntax: arm mrc cpnum op1 CRn CRm op2
    # read Cache Type Register
    set ctr [arm mrc 15 0 0 0 1]
    # 	lsr	\tmp, \tmp, #16
    # 	and	\tmp, \tmp, #0xf		@ cache line size encoding
    # cache line size encoding
    set ctr [expr ($ctr >> 16) & 0xF]
    # 	mov	\reg, #4			@ bytes per word
    #	mov	\reg, \reg, lsl \tmp		@ actual cache line size
    # actual cache line size
    return [expr 4 << $ctr]
}

proc clean_invalidate_dcache_mva_range {start end} {
    if {$start > $end} {
	puts "Error: args are address start address end"; return
    }
    # push	{r0, r1, r2, r3}
    # dcache_line_size r2, r3
    set csize [dcache_line_size]
    # sub	r3, r2, #1
    # bic	r0, r0, r3
    set mask [expr $csize - 1]
    set start [expr $start & ~$mask]

    while {$start < $end} {
	puts [format "Clean and invalidate@0x%08x" $start]
	# 1:
	# mcr	p15, 0, r0, c7, c14, 1		/* clean & invalidate D / U line */
	# Syntax: arm mcr cpnum op1 CRn CRm op2 value
	arm mcr 15 0 7 14 1 $start
	# add	r0, r0, r2
	set start [expr $start + $csize]
	# cmp	r0, r1
	# blo	1b
    }
    # dsb
    arm mcr 15 0 7 10 5 0
    # isb
    arm mcr 15 0 7 5 4 0
    # pop	{r0, r1, r2, r3}
    # bx	lr
}

proc gicd_read {offset} {
    set gicd_addr 0x00a01000
    phys_mem2array gicd 32 [expr $gicd_addr + $offset] 1
    set gicd $gicd(0)
    return $gicd
}

proc irq_stat {stat_name val off} {
    puts -nonewline [format "    %s\t" $stat_name]
    if {$val & (1 << $off)} {
            puts "\[x\]"
    } else {
            puts "\[ \]"
    }
}

proc gic_dist_irq_stat {irq} {
    set grp [expr $irq / 32]
    set off [expr $irq % 32]
    set grp2 [expr $irq / 4]
    set off2 [expr $irq % 4]
    set gicd_ctrl  [gicd_read 0]
    set gicd_type  [gicd_read 4]
    set gicd_iidr  [gicd_read 8]
    set gicd_igrp  [gicd_read [expr 0x80 + 4 * $grp]]
    set gicd_isena [gicd_read [expr 0x100 + 4 * $grp]]
    set gicd_ispen [gicd_read [expr 0x200 + 4 * $grp]]
    set gicd_isact [gicd_read [expr 0x300 + 4 * $grp]]
    set gicd_iprio [gicd_read [expr 0x400 + 4 * $grp2]]
    set gicd_itrgt [gicd_read [expr 0x800 + 4 * $grp2]]
    set gicd_icfg  [gicd_read [expr 0xC00 + 4 * [expr $irq / 16]]]

    puts "Distributor status:"
    puts -nonewline "  Pending interrupts forwarding "
    if {$gicd_ctrl & 1} {
        puts "enabled"
    } else {
        puts "disabled"
    }

    puts -nonewline "  Security extension "
    if {$gicd_type & 0x400} {
             puts -nonewline "enabled"
    } else {
             puts -nonewline "disabled"
    }
    set cpus [expr (($gicd_type >> 5) & 0x7) + 1]
    puts -nonewline [format " on %d cpu(s), " $cpus]
    puts [format "%d IT lines" [expr 32 * ($gicd_type & 0x1F + 1)]]

    puts [format "  IRQ %d is" $irq]
    irq_stat "enabled" $gicd_isena $off
    irq_stat "pending" $gicd_ispen $off
    irq_stat "active" $gicd_isact $off

    puts [format "    priority\t\[%d\]" [expr $gicd_iprio >> ($off2 * 8) & 0xFF]]
    puts [format "    targets\t\[0x%x\]" [expr $gicd_itrgt >> ($off2 * 8) & 0xFF]]
    if {$gicd_icfg & 1 << ($irq % 16)} {
        puts "    Level-sensitive"
    } else {
        puts "    Edge-triggered"
    }
}

proc gicc_read {offset} {
    set gicc_addr 0x00a00100
    phys_mem2array gicc 32 [expr $gicc_addr + $offset] 1
    set gicc $gicc(0)
    return $gicc
}

proc gic_proc_irq_stat {irq proc_id} {
    set gicc_ctrl  [gicc_read 0x00]
    set gicc_pmr   [gicc_read 0x04]
    set gicc_bpr   [gicc_read 0x08]
    set gicc_rpr   [gicc_read 0x14]
    set gicc_hppir [gicc_read 0x18]

    puts [format "CPU %d status:" $proc_id]
    puts -nonewline "  Interrupt signaling "
    if {$gicc_ctrl} {
        puts "enabled"
    } else {
        puts "disabled"
    }

    puts [format "  Interrupt < %d are signaled" $gicc_pmr]
    puts [format "  Proc running at priority %d" $gicc_rpr]

    if {$gicc_hppir & 0x1FF == 0x1FF} {
	puts "  No pending IRQ"
    } else {
	puts [format "  Pending IRQ %d" [expr $gicc_hppir & 0x1FF]]
    }
}

proc gic_irq_stat {irq} {
    dap apsel 1

    gic_dist_irq_stat $irq
    gic_proc_irq_stat $irq 0

    dap apsel 0
}
